# PRD v3 — MuSync: перенос плейлистов между музыкальными сервисами

## 1. Контекст и проблема
- Пользователи хотят переносить свои плейлисты между сервисами (Яндекс Музыка → Spotify и далее) без потерь, дублей и ручной работы.
- Текущий рынок предлагает нестабильные решения с низким матч‑рейтом, отсутствием идемпотентности и прозрачных отчётов.
- Мы делаем перенос безопасным, объяснимым и масштабируемым.

## 2. Цели и метрики успеха (KPI/SLI/SLO)
- Цель: надёжный перенос плейлистов с высоким качеством соответствия и отчётностью.
- Метрики для Итер.1:
  - Match rate ≥ 90% (acceptance датасет), false match ≤ 2%.
  - 0 дублей при повторном запуске (идемпотентность по ключу `(userId, source, target, snapshotHash)`).
  - TTS ≤ 5 минут на 10k треков при учёте RL провайдеров.
  - Полный JSON‑отчёт: причины `not_found`, confidence, сводный summary.
  - Тест‑покрытие критичных модулей ≥ 80%; e2e зелёные.

## 3. Пользователи и персоны
- Power‑users, мигрирующие между сервисами.
- Обычные пользователи, желающие разового переноса.
- Будущие b2b‑интеграции (партнёры/доноры трафика).

## 4. Основные сценарии
- Перенос собственных плейлистов Яндекс Музыки в Spotify с отчётом.
- Повторный запуск с тем же снапшотом без дублей.
- Dry‑run для оценки качества до записи.
- Перенос лайков (Избранного) из Яндекс Музыки в Spotify в два режима:
  - Яндекс Лайки → Spotify Liked Songs (библиотека пользователя)
  - Яндекс Лайки → указанный плейлист Spotify (новый или существующий)

### 4.1. Флоу сценариев переноса

#### A) Яндекс Лайки → Spotify Liked Songs
- Предусловия:
  - Есть валидные токены Spotify и Яндекс.
  - OAuth scopes включают: `user-library-read user-library-modify` и плейлист‑scopes `playlist-read-private playlist-modify-private` (для единообразия логики).
- Шаги:
  1) Загрузка всех лайков пользователя из Яндекс Музыки.
  2) Матчинг в Spotify: ISRC → strict(title+artist) → fuzzy(нормализация, длительность ±2с).
  3) Dry‑run (если включён) — только подсчёт статистики без записи.
  4) Запись совпавших треков в Liked Songs через API "Save Tracks for Current User" батчами по 50.
  5) Чекпойнты и идемпотентность по батчам.
  6) Формирование отчёта: matched/not_found/ambiguous/errors, длительность, метаданные.
- Постусловия:
  - Повторный запуск с тем же снапшотом не создаёт дублей.
  - Неперенесённые треки можно дополнительно отправить в плейлист (ручной или авто) — опционально.

#### B) Яндекс Лайки → Плейлист Spotify (новый/существующий)
- Предусловия:
  - Есть валидные токены Spotify и Яндекс.
  - OAuth scopes включают минимум плейлист‑scopes: `playlist-read-private playlist-modify-private` (опционально `playlist-modify-public` для публичных плейлистов).
- Шаги:
  1) Загрузка всех лайков из Яндекс Музыки.
  2) Матчинг в Spotify (та же стратегия, что выше).
  3) Dry‑run (если включён) — только подсчёт статистики без записи.
  4) Разрешение целевого плейлиста: найти по имени среди owned; при отсутствии — создать.
  5) Добавление совпавших треков в плейлист батчами по 100.
  6) Чекпойнты и идемпотентность по батчам.
  7) Отчёт/метрики как в сценарии A.
- Постусловия:
  - Повторный запуск с тем же снапшотом не создаёт дублей.

#### C) Яндекс Плейлист → Плейлист Spotify (существующий/новый)
- Предусловия:
  - Валидные токены; scopes: `playlist-read-private playlist-modify-private` (+ `playlist-modify-public` при необходимости).
- Шаги:
  1) Скан исходного плейлиста (только owned по политике MVP).
  2) Матчинг в Spotify (ISRC → strict → fuzzy).
  3) Dry‑run — опционально.
  4) Разрешение целевого плейлиста по имени (по умолчанию имя источника) или создание нового.
  5) Добавление батчами по 100 с ретраями и уважением `Retry-After`.
  6) Чекпойнты и отчёт.
- Постусловия:
  - Идемпотентность по ключу (см. раздел 6 и `_cursorrules`).

## 5. Область решения (Scope/Anti‑scope)
- In scope (Итер.1):
  - Источник: Яндекс Музыка (только собственные плейлисты пользователя).
  - Приёмник: Spotify.
  - CLI/джоба без UI, минимальный HTTP только для OAuth callback/health.
  - Матчинг: ISRC → exact(title+artist+duration±2s) → fuzzy(нормализация+левенштейн).
  - Идемпотентность, батчи ≤ 100, чекпойнты, backoff с учётом `retry-after`.
  - Конфигурация через `.env`; секреты вне кода.
  - Миграция лайков Яндекс → Spotify:
    - В Liked Songs (требует `user-library-read user-library-modify`).
    - В указанный плейлист (только playlist‑scopes).
- Out of scope (Итер.1): подписанные плейлисты, расписание, SaaS‑мультиаккаунт, биллинг, UI.

## 6. Требования
### 6.1 Функциональные требования (FR)
- FR‑1: Импорт собственных плейлистов из Яндекс Музыки.
- FR‑2: Поиск соответствий треков в Spotify по многоступенчатой стратегии.
- FR‑3: Батчевое добавление треков с чекпойнтами и ретраями.
- FR‑4: Dry‑run режим без записи.
- FR‑5: Генерация JSON‑отчёта по итогам переноса.
- FR‑6: Перенос лайков Яндекс → Spotify Liked Songs (50/запрос).
- FR‑7: Перенос лайков Яндекс → указанный плейлист Spotify (100/запрос).

### 6.2 Нефункциональные требования (NFR)
- Производительность: TTS ≤ 5 мин на 10k треков.
- Надёжность: идемпотентность, повторяемость, устойчивость к RL и временным сбоям.
- Безопасность: минимальные scopes, шифрование секретов, маскирование логов.
- Наблюдаемость: структурированные логи, метрики этапов, корреляция по `jobId`.
- Портируемость: 12‑factor, контейнеризация, внешние БД/очереди/секреты.

### 6.3 OAuth scopes по сценариям
- Плейлисты: `playlist-read-private playlist-modify-private` (+ `playlist-modify-public` по необходимости).
- Лайки → Liked Songs: дополнительно требуются `user-library-read user-library-modify`.

## 7. Ограничения и зависимости
- Внешние API: квоты и RL Яндекс/Spotify; возможные изменения контрактов.
- Лимиты на размер/скорость добавления треков.
- Необходимость пользовательских OAuth токенов и Redirect URI для Spotify.

## 8. Риски и план управления
- Низкий матч‑рейт → улучшение нормализации/фаззи, ручные правила, отчёт причин.
- Жёсткий rate‑limit → батчи, backoff, уважение `retry-after`, чекпойнты.
- Ошибки OAuth/секретов → минимальные scopes, хранение секретов вне кода, ротация.

## 9. Открытые вопросы
- Политика зеркалирования vs append (в Итер.1 — append).
- Порог fuzzy и top‑k кандидатов для explainability.
- TTL чекпойнтов и окно повторного запуска.

## 10. План релиза и этапы (итерации)
- Итерация 1 (MVP CLI): Яндекс → Spotify, только собственные плейлисты, без UI.
- Итерация 2 (UX и расширяемость): новый провайдер, планировщик, дельта‑синк, UI статуса.
- Итерация 3 (SaaS и масштаб): очередь задач, воркеры, тенантинг, квоты, RBAC.

## 11. DoR/DoD
### Итерация 1 — DoR
- Подготовлены тест‑аккаунты, scopes, redirect URI, acceptance CSV.
- Tie‑break по плейлистам подтверждён; переносим только «собственные».
- Формат отчёта и метрик согласован; `DRY_RUN` и ключ идемпотентности спроектированы.
### Итерация 1 — DoD
- Match‑рейт ≥ 90%; 0 дублей; TTS ≤ 5 мин.
- Юнит/контракты ≥ 80% покрытия; e2e зелёные.
- JSON‑отчёт и метрики соответствуют схеме; логи без секретов.
### Итерация 2 — DoR
- Порт `MusicProvider` заморожен; контрактные тесты готовы.
- Выбран второй провайдер; UI‑макет статуса; планировщик и дельта‑синк спроектированы.
### Итерация 2 — DoD
- Новый провайдер без изменений domain; дельта‑синк < 60 сек; алерты/метрики/статусы.
### Итерация 3 — DoR
- Выбран стек очередей/хранилищ; модель tenancy и квот согласована; SLO/ошибкобюджет.
### Итерация 3 — DoD
- P95 ≤ 2 мин при 100 параллельных задачах; изоляция tenant‑ов; circuit breaker и дросселирование.

## 12. Критерии приемки
- Acceptance сценарии из `TEST_PLAN.md` должны проходить с указанными порогами.
- Все команды/тесты завершаются автоматически с корректными exit codes, без зависаний > 1 минуты (таймауты по умолчанию).

## 13. Приложения
- Ссылка на архитектуру: `ARCHITECTURE.md`.
- ADR: `docs/adr/*` (идемпотентность, матчинг, RL/backoff, очередь/воркеры).
- Бэклог: `BACKLOG.md` (итерация 1).

---

Чеклист PRD v3:
- [x] Контекст, цели, метрики
- [x] Scope/Anti‑scope по итерациям
- [x] FR/NFR
- [x] DoR/DoD
- [x] Acceptance/версии, ссылки на архитектуру/ADR/бэклог

