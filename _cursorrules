# Project Rules and Methodology

## Project Context (General)

This repository will be used to build MuSync - a music playlist transfer service between streaming platforms. The rules below are stack-agnostic and focus on methodology, quality, and collaboration. Prefer asynchronous designs where appropriate, but do not assume a specific language or framework.

## MANDATORY: Read Rules First

**BEFORE making any code changes, you MUST read and follow:**

- `PROJECT_RULES.md` - Development methodology and rules (MUST READ FIRST before ANY development / НЕОБХОДИМО ОБЯЗАТЕЛЬНО перед ЛЮБОЙ разработкой)
- `docs/PRD.md` - Product requirements and iterations
- `ARCHITECTURE.md` - System architecture and layers
- `BACKLOG.md` - Current iteration tasks and dependencies
- `TEST_PLAN.md` - Testing strategy and acceptance criteria

**These documents contain specific requirements, constraints, and workflows that MUST be followed.**

### MuSync-Specific Requirements

- **Hexagonal Architecture**: Clear separation of layers (Domain ← Application → Infrastructure)
- **Idempotency**: Key `(userId, source, target, snapshotHash)` with checkpointing
- **Rate Limiting**: Respect `retry-after`, exponential backoff, circuit breakers
- **Structured Logging**: No secrets in logs, correlation by jobId
- **Acceptance Criteria**: Match rate ≥90%, TTS ≤5min, 0 duplicates, ≥80% test coverage

## Code Standards

- Use type annotations where supported by the language
- Follow the community style guide for the chosen language and enforce formatting with a formatter/linter
- Write comprehensive automated tests for every feature (unit, integration, and scenario tests)
- Use value objects/data classes/DTOs for data models
- Implement robust error handling with clear, actionable messages

## Architecture Patterns

- Repository pattern (data access contracts separated from implementations)
- Service/Application layer for business logic orchestration
- Workflow/Use-case layer for user interactions and long-running flows
- Dependency injection for testability and composability
- Cross-cutting concerns extracted (logging, tracing, auth, config)

## Shared Code & Mixin Methodology

### 1. Mixin-First Approach

- Identify common functionality across modules early
- Create mixins/traits/components for shared behavior before implementing specifics
- Use composition over inheritance to reduce coupling and duplication

### 2. Shared Service Patterns

- Extract common service logic into base classes/utilities
- Centralize validation and error handling
- Build reusable adapters for external systems

### 3. Interface Component Sharing

- Create shared UI/interaction components (navigation, pagination, keyboards/menus, common prompts)
- Reuse keyboard/menu/nav builders and state management across flows

### 4. Service Layer Sharing

- Identify common CRUD and query patterns
- Implement reusable validation and authorization mixins
- Provide shared logging and metrics helpers

### 5. Data Access Sharing

- Provide base repository interfaces and default implementations
- Encapsulate transaction management and retry policies
- Standardize model validation and mapping

## Testing Requirements

- Write scenario/integration tests for key user journeys
- Use async-capable test runners where relevant
- Mock or stub external dependencies (network, storage, queues)
- Test error and edge conditions
- Verify complete workflows end-to-end

## Documentation

- Document architectural decisions (ADRs)
- Keep a clear changelog and meaningful commit messages
- Maintain a comprehensive README and onboarding guides
- Document public APIs and interfaces
- Explain important business rules and workflow contracts

## Development Workflow

**Before any development, read and follow `PROJECT_RULES.md` (9-step methodology).**

**Key MuSync requirements:**

- Hexagonal architecture with clear layer separation
- Idempotent operations with checkpointing
- Rate limiting and retry policies
- Structured logging without secrets
- Comprehensive test coverage (≥80%)

## Document Navigator (Stage-based)

- Stage 1–3 (Idea → Plan → Confirm):
  - Точка входа: этот документ. Далее `PROJECT_RULES.md` (процесс 9 этапов, гейтинг).
  - Затем `docs/PRD.md` §§ 1–4 (цели, метрики, сценарии/flows).
  - Затем `ARCHITECTURE.md` §§ 2–4 (принципы, слои, порты).
  - Optional: `BACKLOG.md` как референс‑разбивка. При расхождениях приоритет: `_cursorrules` → `PROJECT_RULES.md` → `docs/PRD.md` → `ARCHITECTURE.md`.

- Stage 4–5 (Test planning → Confirm tests):
  - `TEST_PLAN.md` (юнит/контракты/e2e, acceptance).
  - Схемы: `docs/report_schema.json`, `docs/metrics_schema.json`, `docs/checkpoint_schema.json`.

- Stage 6 (Development):
  - `ARCHITECTURE.md` §§ 3–6, 7 (слои, порты, политики, потоки данных).
  - Доменные порты/сущности: `app/domain/*`.
  - Оркестрация/пайплайны: `app/application/*`.
  - Кросс‑каттинги: `app/crosscutting/*` (config, logging, metrics, reporting).
  - Scopes OAuth: `docs/PRD.md` § 6.3.
  - Операционный флоу: `docs/FLOW_RUNBOOK.md`.

- Stage 7 (Testing):
  - `pytest.ini`, `scripts/run_tests_with_gating.py`, `app/tests/*`.

- Stage 8 (Report & Metrics):
  - Репортинг: `app/crosscutting/reporting.py`; артефакты в `reports/`.
  - Метрики: `app/crosscutting/metrics.py`; соответствие схемам.

- Stage 9 (Docs & Release):
  - Обновить `README.md`, `CHANGELOG.md`, `docs/adr/*`, при необходимости `ARCHITECTURE.md`/`PRD.md`.
  - PR‑чеклист: см. `PROJECT_RULES.md`.

### E2E Flow quicklinks

- Yandex liked → Spotify liked: `docs/PRD.md` § 4.1; также см. `ARCHITECTURE.md` § 7 (потоки данных).
- Yandex playlist → Spotify playlist: `docs/PRD.md` § 4.3.
- Идемпотентность/чекпойнты: `docs/PRD.md` §§ 2.12, 6.1; `ARCHITECTURE.md` § 6.1.
 - Операционный ранбук: `docs/FLOW_RUNBOOK.md`.

### Operational flags (execute policy)

- Yellow:
  - Match‑rate ниже цели (90%) на acceptance — продолжать, зафиксировать в отчёте; пересмотреть нормализацию/пороги.
  - Повторяющиеся 429 — уважать `retry-after`, уменьшать размер батча временно.
- Red (abort и сформировать error‑report):
  - Ошибки OAuth/недостаточные scopes.
  - >3 подряд 429 с `retry-after > 60s`.
  - Сбой записи чекпойнта >3 попыток.
  - Error‑rate записи >5% на последних 1000 операций.

### Backlog policy

- `BACKLOG.md` — опциональный референс для детальной разбивки задач и статусов.
- При любых расхождениях приоритет документов: `_cursorrules` (этот навигатор) → `PROJECT_RULES.md` → `docs/PRD.md` → `ARCHITECTURE.md`.
- Если `BACKLOG.md` перестаёт добавлять ценность, допускается его архивировать или объединить с Issue‑трекером.

## Mixin Implementation Guidelines

### When to Use Mixins

- Functionality is shared across multiple modules/classes
- Common UI/interaction patterns (navigation, pagination, prompts)
- Shared business rules (validation, authorization)
- Common data access operations (CRUD, queries)
- Workflow/state management patterns

### Mixin Design Principles

- Single, focused responsibility
- Clear, descriptive method names
- Comprehensive type hints where possible
- Minimal assumptions about host class
- Testable in isolation

### Mixin Naming Conventions

- Use descriptive names ending with "Mixin" (or language-idiomatic alternative)
- Group related mixins in shared modules/packages
- Use method names that clearly indicate intent

### Testing Mixins

- Test in isolation with mocks/fakes
- Test in composition with representative host classes
- Verify correct behavior when multiple mixins are combined
- Cover error paths and edge cases

## Shared Code Pattern Sketches (Language-Agnostic)

### 1. NavigationMixin

```pseudo
trait NavigationMixin {
  async handleBack(request, context): void
  async showMainView(request, context): void
}
```

### 2. ServiceValidationMixin

```pseudo
trait ServiceValidationMixin {
  async ensureUserExists(userId): User
  async ensureHasAccess(subjectId, resourceId, permission): void
}
```

### 3. RepositoryCrudMixin

```pseudo
trait RepositoryCrudMixin<T> {
  async create(entity: T): Id
  async getById(id: Id): Optional<T>
  async update(entity: T): void
  async delete(id: Id): bool
}
```

<!-- Role-Based Repository Separation section removed to reduce noise for junior onboarding; can be reintroduced via ADR when needed. -->

## Success Criteria for Shared Code

- Reduce code duplication by at least 30%
- Improve test coverage via shared test patterns
- Speed up feature development through reusable components
- Ensure consistent behavior across similar features
- Simplify maintenance and bug fixes
- Keep patterns and usage well documented

## MuSync-Specific Success Criteria

- Match rate ≥ 90% on acceptance dataset
- Zero duplicates on repeated runs (idempotency)
- TTS ≤ 5 minutes for 10k tracks
- Test coverage ≥ 80% for critical modules
- All E2E tests pass acceptance criteria
- Structured logs without secrets
- Proper rate limiting and error handling
